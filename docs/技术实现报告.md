# AI-Powered Shopping Assistant 技术实现报告

## 1. 项目定位与目标

该项目实现了一个基于 **LangGraph + LangChain + OpenAI** 的多角色购物智能体，覆盖：

- 商品搜索（向量语义检索 + 结构化筛选）
- 购物车增删改查与下单
- 销售到客服的自动路由
- 客服侧人工审批中断（Human-in-the-loop）
- Streamlit 可视化对话界面

其核心价值在于将「自然语言交互」映射为「可控的工具调用流程」，并通过状态图管理多轮上下文与角色切换。

---

## 2. 总体架构

## 2.1 分层结构

1. **交互层（UI）**：`app.py`
   - 负责会话展示、输入提交、审批输入、购物车侧边栏。
2. **编排层（Orchestration）**：`src/graph.py`
   - 基于 `StateGraph` 定义节点、路由、条件边与中断恢复。
3. **智能体层（Agents）**：`src/assistants.py`
   - 销售智能体与客服智能体，分别绑定不同提示词与工具集。
4. **能力层（Tools）**：`src/tools.py`
   - 结构化检索、向量检索、购物车、路由/升级 schema、工具错误兜底。
5. **提示词层（Prompts）**：`src/prompts.py`
   - Sales 与 Support 的系统提示词与行为约束。
6. **数据与索引层**：
   - 原始 CSV 数据集：`dataset/*.csv`
   - 向量库构建脚本：`src/build_vector_db.py`
   - Chroma 持久化目录：`./vector_db`
7. **运行入口与调试层**：`src/conversation_runner.py`
   - 单轮执行、审批恢复、历史打印。

## 2.2 技术栈落地

依赖显示项目采用：LangGraph、LangChain、OpenAI、Chroma、HuggingFace Embedding、Pandas、Streamlit、Pytest。`requirements.txt`。

---

## 3. 智能体模块拆解

## 3.1 销售智能体（sales_assistant）

- 模型：`ChatOpenAI(model='gpt-4o')`
- 提示词：`sales_rep_prompt`
- 可用工具：
  - `RouteToCustomerSupport`
  - `search_tool`
  - `structured_search_tool`
  - `cart_tool`
  - `view_cart`

执行流程：
1. 从 `RunnableConfig` 读取 `thread_id` 与 `user_id`（默认 1）。
2. 写入全局上下文：`set_thread_id`、`set_user_id`。
3. 调用 `sales_runnable.invoke(state)`。
4. 统一返回 `{"messages": [...]}` 以适配图状态更新。

> 注意：销售节点函数是同步 `def`，不是 async；但测试中存在 `asyncio.run(...)` 调用该函数的写法，属于测试代码与实现不一致的风险点（详见第 9 节）。

## 3.2 客服智能体（support_assistant）

- 提示词：`support_prompt`
- 工具：`EscalateToHuman`

执行流程：
1. 设置 thread 上下文。
2. 调用客服 runnable。
3. 返回单条 AI 消息。

---

## 4. 状态机（LangGraph）设计

## 4.1 状态定义

`State`（`TypedDict`）包含：

- `messages`: 消息列表（通过 `add_messages` 聚合）
- `dialog_state`: 角色栈（`sales_rep` / `customer_support`）
- `need_human_approval`: 是否等待人工审批
- `supervisor_response`: 主管响应

`update_dialog_stack` 的行为：
- `right is None`：保持原栈
- `right == "pop"`：弹栈
- 其他：入栈

## 4.2 节点

- `sales_rep`
- `customer_support`
- `sales_tools`
- `support_tools`
- `after_sales_tool`
- `after_support_tool`
- `human_approval`

## 4.3 关键路由逻辑

1. **起点路由**：若 `dialog_state` 顶部是 `customer_support`，直接进客服；否则进销售。
2. **销售节点后**：有 `tool_calls` 则进入 `sales_tools`，否则结束。
3. **after_sales_tool**：若工具名为 `RouteToCustomerSupport`，写入 `dialog_state=customer_support`。
4. **客服节点后**：有工具调用进 `support_tools`，否则结束。
5. **after_support_tool**：若调用 `EscalateToHuman`，解析 severity/summary 并写入 `need_human_approval`。
6. **human_approval**：触发 `interrupt(...)`，等待外部 supervisor 输入；恢复后追加一条 `[SUPERVISOR RESPONSE] ...` 的 HumanMessage，再回到客服节点。

该设计实现了典型的 **Agent + Tools + Human Approval Gate** 闭环。

---

## 5. 工具模块详解（输入/输出/行为）

## 5.1 structured_search_tool

**输入参数（可选）**：

- `product_name`: 子串匹配
- `department`: 枚举（来自部门表）
- `aisle`
- `reordered`（需 `history_only=True`）
- `min_orders`（需 `history_only=True`）
- `order_by`: `count` / `add_to_cart_order`
- `ascending`
- `top_k`
- `group_by`: `department` / `aisle`
- `history_only`

**内部流程**：

1. 全量模式：直接以 `products` 为基础。
2. 历史模式：
   - 读取当前 `user_id`
   - 过滤用户订单
   - 与 `prior` 聚合得到 `count/reordered_count/add_to_cart_order`
3. 与 `departments/aisles` 关联补充语义字段。
4. 应用过滤、分组、排序、截断。

**输出**：`list[dict]`

- 明细模式：`product_id/product_name/aisle/department/...`
- 分组模式：`department|aisle + num_products`
- 异常：`[{"error": ...}]`

## 5.2 search_products + search_tool

### search_products

**输入**：`query: str`, `top_k: int=5`

**过程**：
1. `make_query_prompt` 将 query 包装为检索提示句。
2. 获取向量库 `get_vector_store()`。
3. `similarity_search(query_text, k=top_k)`。
4. 组装 metadata + page_content。

**输出**：商品字典列表。

### search_tool（LLM可调用工具）

**输入**：`query: str`

**输出**：格式化文本（人类可读），包含：
- Product Name + ID
- Aisle
- Department
- Details

空结果时返回固定字符串：`No products found matching your search.`

> 关键风险：`get_vector_store()` 目前是 `pass`，实际运行会导致向量检索链路不可用，除非被测试 mock 掉（详见第 9 节）。

## 5.3 cart_tool

**输入**：
- `cart_operation`: `add/remove/update/buy`
- `product_id`（操作相关）
- `quantity`（默认 1）

**会话隔离机制**：
- 使用 `_current_thread_id` + `_cart_storage: Dict[thread_id -> Dict[product_id->qty]]`

**输出**：自然语言字符串（成功/失败/提示）

**行为细节**：
- `add`：存在则累加，不存在则新建。
- `update`：必须已在购物车。
- `remove`：支持按数量减少或整项删除。
- `buy`：清空购物车。

## 5.4 view_cart

**输入**：无

**输出**：
- 空购物车：`Your cart is currently empty.`
- 非空：多行文本，`- 商品名 (ID: xx) × qty`

## 5.5 路由/升级 schema 工具

- `RouteToCustomerSupport(reason: str)`：销售侧路由到客服。
- `EscalateToHuman(severity: str, summary: str)`：客服侧触发人工审批。

它们是 Pydantic schema，不做业务逻辑计算，而是作为 LLM 可调用动作规范。

## 5.6 工具异常兜底

`create_tool_node_with_fallback(tools)` 会把 `ToolNode` 包装为带 fallback 的节点：
- fallback 函数：`handle_tool_error`
- 异常键：`exception_key="error"`
- 输出 `ToolMessage` 告知模型修复调用

---

## 6. 提示词工程（Prompt Engineering）

## 6.1 销售提示词（sales_rep_prompt）关键约束

系统提示词包含一个较完整的“TOOL MASTERY GUIDE”，明确了：

1. **检索策略**：
   - 语义检索用于自然语言描述。
   - 结构化检索用于过滤、历史偏好、统计。
2. **购物车策略**：
   - 先查再加（Search First Principle）。
   - 展示“名称 + ID”，避免只给 ID。
3. **升级策略**：
   - 退款、损坏、账户等问题必须触发 `RouteToCustomerSupport`。
4. **历史数据策略**：
   - 建议先征求用户是否访问历史。

这属于“长指令 + 案例驱动”风格，有利于提升工具选择稳定性。

## 6.2 客服提示词（support_prompt）关键约束

重点强调：

- 客服可处理一般问题，但 **无权直接批准退款**。
- 出现退款、要求经理、情绪激动、复杂问题等场景，必须调用 `EscalateToHuman`。
- 收到 `[SUPERVISOR RESPONSE]` 后必须显式确认并给出下一步。

该提示词在权限边界与责任链方面比较清晰，适合生产中“AI处理 + 人工授权”的合规流程。

---

## 7. 端到端链路（输入/输出视角）

## 7.1 普通销售场景

**输入**：用户文本（如“帮我找高蛋白早餐”）

**链路**：
1. UI 写入 user message。
2. Graph 进入 `sales_rep`。
3. LLM 生成工具调用（`search_tool` / `structured_search_tool`）。
4. `sales_tools` 执行工具并回填 `ToolMessage`。
5. 回到 `sales_rep` 汇总并自然语言回复。

**输出**：
- chat 中可见 tool call + tool result + assistant response
- 购物车可在侧边栏同步显示

## 7.2 升级到客服

**输入**：用户提出退款/损坏等诉求。

**链路**：
1. 销售 LLM 调用 `RouteToCustomerSupport`。
2. `after_sales_tool` 检测后设置 `dialog_state=customer_support`。
3. 后续 turn 默认从客服节点启动。

**输出**：角色切换至客服处理。

## 7.3 客服触发人工审批

**输入**：客服判断需升级（如退款审批）。

**链路**：
1. 客服 LLM 调 `EscalateToHuman`。
2. `after_support_tool` 提取 severity/summary，写入 `need_human_approval`。
3. 路由到 `human_approval`，触发 `interrupt`。
4. UI 展示审批输入框；主管输入后用 `Command(resume=...)` 恢复。
5. 图返回客服节点，客服根据主管指令答复。

**输出**：完整闭环可追踪的审批对话。

---

## 8. Streamlit 前端实现要点

1. **会话状态管理**：
   - `thread_id/messages/chat_history/pending_approval/current_mode/cart_items`。
2. **图调用**：
   - 正常输入：`graph.invoke(input_state, config)`
   - 审批恢复：`graph.invoke(Command(resume=supervisor_response), config)`
3. **消息可视化分类**：
   - `user/assistant/tool_call/tool_result/supervisor/error`
4. **购物车双重同步策略**：
   - 从 `view_cart` 结果解析
   - `direct_cart_update()` 直接读取工具层 cart（提高一致性）

---

## 9. 质量保障与当前技术风险

## 9.1 测试覆盖到的核心点

- Graph 路由：`after_sales_tool` 的状态切换。
- assistant 调用契约：返回 `{"messages": ...}`，并设置 thread/user。
- 工具链路：search -> cart -> view_cart 的基本流程。

## 9.2 主要风险/债务

1. **向量库初始化未完成**
   - `get_vector_store()` 为空实现（`pass`），真实环境的 `search_tool` 会失败。
2. **测试与实现在 async/sync 上有偏差**
   - 测试中多处 `asyncio.run(sales_assistant(...))`，而实现是同步函数。
3. **全局变量线程安全性**
   - `_current_thread_id`、`_current_user_id`、`_cart_storage` 为进程内全局变量，多 worker/多实例下需外部状态存储。
4. **解析鲁棒性**
   - `after_support_tool` 通过字符串拆分 ToolMessage 内容解析 severity/summary，格式变化时易脆弱。

---

## 10. 数据与向量检索实现

## 10.1 向量库构建脚本

`src/build_vector_db.py` 提供离线索引流程：

1. 读取 products/aisles/departments。
2. 清洗并校验 aisle_id/department_id。
3. 构造 embedding 文本：`"{name}, found in ..."`。
4. 转 LangChain `Document`。
5. 使用 `mixedbread-ai/mxbai-embed-large-v1` 生成向量。
6. 分批写入 Chroma。

## 10.2 线上检索路径

理论上：`search_tool -> search_products -> get_vector_store -> Chroma.similarity_search`。

即：离线构建 + 在线召回 + LLM 汇总解释。

---

## 11. MCP Web Search 扩展能力

`src/web_search_mcp.py` 封装了 Brave MCP 工具加载：

- 若无 `BRAVE_API_KEY`：返回降级 tool（说明不可用）
- 若初始化失败：返回错误降级 tool
- 若成功：过滤 Brave 相关工具并返回

这让系统可以按环境自动扩展到“外部网络检索”，但当前主流程中尚未在 graph/assistants 里接入该工具。

---

## 12. 总结

该项目的工程价值在于：

- 用 LangGraph 将“对话 -> 工具 -> 状态迁移 -> 人工审批”显式建模；
- 用双智能体（销售/客服）实现职责分离；
- 用提示词明确工具策略与权限边界；
- 用 Streamlit 提供了可观测、可调试的交互界面。

如果要走向生产，优先建议：

1. 完成 `get_vector_store()` 并补齐真实检索集成测试；
2. 把全局状态迁移到 Redis/数据库；
3. 统一 async/sync 设计并修正测试；
4. 将审批信息改为结构化 payload 传递而非字符串解析。
